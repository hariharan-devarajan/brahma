import argparse
import clang.cindex as cix
import os
import shutil
from datetime import datetime
from string import Template

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Generate interfaces script")
parser.add_argument("--libclang-path", type=str, help="Path to libclang", required=True)
parser.add_argument(
    "--hdf5-header-path",
    action="extend",
    nargs="+",
    type=str,
    help="Path to HDF5 library header file",
)
parser.add_argument(
    "--hdf5-version",
    action="extend",
    nargs="+",
    type=str,
    help="Version of HDF5 related to header file",
)
parser.add_argument(
    "--mpio-header-path",
    type=str,
    help="Path to MPIO library header file",
)
parser.add_argument(
    "--verbose", action="store_true", help="Print verbose output", default=False
)
parser.add_argument(
    "--with-tests", action="store_true", help="Generate tests", default=False
)
cli_args = parser.parse_args()

cix.Config.set_library_file(cli_args.libclang_path)


TEMPLATE_IMPLEMENTATION = Template("""
///
/// This file is generated by tools/generate_interfaces.py
/// Generated on: ${timestamp}
///

#include <brahma/interface/${file_name}.h>
#include <stdexcept>
#ifdef ${enable_macro_name}
                                   
namespace brahma {
    std::shared_ptr<${namespace}> ${namespace}::my_instance = nullptr;
                                   
    std::shared_ptr<${namespace}> ${namespace}::get_instance() {
        if (my_instance == nullptr) {
            BRAHMA_LOG_INFO("${namespace} class not intercepted but used", "");
            my_instance = std::make_shared<${namespace}>();
        }
        return my_instance;
    }
                                   
    int ${namespace}::set_instance(std::shared_ptr<${namespace}> instance_i) {
        if (instance_i != nullptr) {
            my_instance = instance_i;
            return 0;
        } else {
            BRAHMA_LOG_ERROR("%s instance_i is not set", "${namespace}");
            throw std::runtime_error("instance_i is not set");
        }
    }
 
    ${wrapper_functions}
} // namespace brahma

#endif // ${enable_macro_name}
""")

TEMPLATE_INTERFACE = Template("""
///
/// This file is generated by tools/generate_interfaces.py
/// Generated on: ${timestamp}
///

#ifndef BRAHMA_${namespace}_H
#define BRAHMA_${namespace}_H
#include <brahma/brahma_config.hpp>
#ifdef ${enable_macro_name}
#include <brahma/interceptor.h>
#include <brahma/interface/interface.h>
#include <${lib_header_file_name}>

namespace brahma {
    class ${namespace} : public Interface {
        private:
            static std::shared_ptr<${namespace}> my_instance;
                             
        public:
            ${namespace}() : Interface() {};
            
            virtual ~${namespace}() {};

            static std::shared_ptr<${namespace}> get_instance();
                             
            static int set_instance(std::shared_ptr<${namespace}> instance_i);
                              
            template <typename C>
            size_t bind(const char *name, uint16_t priority);
                              
            ${virtual_functions}

            ${macro_vars}
    };
} // namespace brahma

${macro_typedefs}

template <typename C>
size_t brahma::${namespace}::bind(const char *name, uint16_t priority) {
    ${macro_bindings}
                              
    num_bindings = bindings.size();
    if (num_bindings > 0) {
        char tool_name[64];
        sprintf(tool_name, "%s_${file_name}", name);
        gotcha_binding_t *raw_bindings = bindings.data();
        gotcha_wrap(raw_bindings, num_bindings, tool_name);
        gotcha_set_priority(tool_name, priority);
    }
    return num_bindings;  
}

#endif // ${enable_macro_name}
#endif // BRAHMA_${namespace}_H
""")

TEMPLATE_MACRO_BINDING = Template("""
GOTCHA_BINDING_MACRO(${function_name}, brahma::${namespace});
""")

TEMPLATE_MACRO_TYPEDEF = Template("""
GOTCHA_MACRO_TYPEDEF(${function_name}, ${return_type}, (${args}), (${arg_names}), brahma::${namespace});
""")

TEMPLATE_MACRO_VAR = Template("""
GOTCHA_MACRO_VAR(${function_name})
""")

TEMPLATE_TEST = Template("""
///
/// This file is generated by tools/generate_interfaces.py
/// Generated on: ${timestamp}
///

#include <brahma/brahma.h>
#ifdef ${enable_macro_name}
#include <${lib_header_file_name}>

namespace brahma {
    class ${namespace}Test : public ${namespace} {
        private:
            static std::shared_ptr<${namespace}Test> my_instance;
                             
        public:
            ${namespace}Test() : api_count(0) {};
            
            virtual ~${namespace}Test() {};

            static std::shared_ptr<${namespace}Test> get_instance() {
                if (my_instance == nullptr) {
                    my_instance = std::make_shared<${namespace}Test>();
                    ${namespace}::set_instance(my_instance);
                }
                return my_instance;
            }

            size_t api_count;
                              
            ${function_overrides}
    };

std::shared_ptr<${namespace}Test> ${namespace}Test::my_instance = nullptr;

} // namespace brahma

#endif // ${enable_macro_name}

void __attribute__((constructor)) test_init() {
#ifdef ${enable_macro_name}
  auto test_instance = brahma::${namespace}Test::get_instance();
  test_instance->bind<brahma::${namespace}Test>("${namespace}Test", 0);
#endif
}

void __attribute__((destructor)) test_finalize() {
#ifdef ${enable_macro_name}
  auto test_instance = brahma::${namespace}Test::get_instance();
  test_instance->unbind();
  assert(test_instance->num_bindings == test_instance->api_count);
#endif
}

int main(int argc, char* argv[]) {
    #ifdef ${enable_macro_name}

    ${test_functions}

    #endif

    exit(0);
    return 0;
}

""")

TEMPLATE_TEST_FUNCTION_OVERRIDE = Template("""
${return_type} ${function_name}(${args}) override {
    api_count++;
    ${return_value}
}
""")


TEMPLATE_VERSION_CONDITION = Template("""
#if ${version_condition} ${function} #endif
""")

TEMPLATE_VIRTUAL_FUNCTION = Template("""
virtual ${return_type} ${function_name}(${args});
""")

TEMPLATE_WRAPPER_FUNCTION = Template("""
${return_type} ${namespace}::${function_name}(${args}) {
    BRAHMA_UNWRAPPED_FUNC(${function_name}, ${return_type}, (${arg_names}));
    return result;
}
""")

TEMPLATE_WRAPPER_FUNCTION_VOID = Template("""
void ${namespace}::${function_name}(${args}) {
    BRAHMA_UNWRAPPED_FUNC_VOID(${function_name}, (${arg_names}));
}
""")


def build_test_function(function_name, function_args, underlying_types):
    test_function = f"\n{function_name}("

    if len(function_args) == 0 or function_args[0] == "void":
        test_function += ");\n"
        return test_function

    for i, arg in enumerate(function_args):
        arg_type = arg.split(" ")[0].strip()
        orig_arg_type = arg_type
        is_array = "[]" in arg
        is_pointer = "*" in arg
        is_double_pointer = "**" in arg
        if is_pointer:
            print(arg)
        if arg_type in underlying_types:
            arg_type = underlying_types[arg_type]
        if i > 0:
            test_function += ", "
        if arg_type == "enum":
            if is_pointer:
                test_function += "NULL"
            else:
                test_function += f"static_cast<{orig_arg_type}>(0)"
        elif is_integer_type(arg_type) and not is_pointer:
            test_function += "0"
        elif arg_type in ["float", "double"] and not is_pointer:
            test_function += "0.0"
        elif arg_type == "char":
            if is_double_pointer:
                test_function += "NULL"
            elif is_pointer or is_array:
                test_function += 'const_cast<char*>("")'
            else:
                test_function += "'\\0'"
        elif arg_type == "bool" and not is_pointer:
            test_function += "false"
        else:
            test_function += "NULL"

    test_function += ");\n"
    return test_function


def is_basic_kind(underlying_type):
    return underlying_type.kind in {
        cix.TypeKind.CHAR_S,
        cix.TypeKind.CHAR_U,
        cix.TypeKind.DOUBLE,
        cix.TypeKind.FLOAT,
        cix.TypeKind.INT,
        cix.TypeKind.LONG,
        cix.TypeKind.LONGLONG,
        cix.TypeKind.SHORT,
        cix.TypeKind.UINT,
        cix.TypeKind.ULONG,
        cix.TypeKind.ULONGLONG,
        cix.TypeKind.USHORT,
    }


def is_integer_type(underlying_type):
    return underlying_type in [
        "int",
        "long",
        "long int",
        "long long",
        "size_t",
        "unsigned",
        "unsigned int",
        "unsigned long",
        "unsigned long long",
    ]


def version_number(version_string: str):
    version_parts = version_string.split(".")
    while len(version_parts) < 3:
        version_parts.append("0")
    return (
        int(version_parts[0]) * 100000
        + int(version_parts[1]) * 100
        + int(version_parts[2])
    )


def get_struct_definition(cursor, struct_children):
    struct_def = f"typedef struct {cursor.spelling} {{\n"
    for field in struct_children:
        struct_def += f"    {field.type.spelling} {field.spelling};\n"
    struct_def += f"}} {cursor.spelling};\n"
    return struct_def


def get_enum_definition(cursor, enum_children):
    enum_def = f"typedef enum {cursor.spelling} {{\n"
    for enum_const in enum_children:
        if enum_const.kind == cix.CursorKind.ENUM_CONSTANT_DECL:
            enum_def += f"    {enum_const.spelling} = {enum_const.enum_value},\n"
    enum_def += f"}} {cursor.spelling};\n"
    return enum_def


def print_function(cursor, function_hash=""):
    if not cli_args.verbose:
        return
    print("-" * 80)
    print(f"[func] {cursor.spelling} ({function_hash})")
    for i, arg in enumerate(cursor.get_arguments()):
        args = []
        args.append(f"[arg{i}]")
        args.append(f"s: {arg.spelling}")
        args.append(f"tk: {arg.type.kind}")
        args.append(f"ts: {arg.type.spelling}")
        if arg.type.kind == cix.TypeKind.INCOMPLETEARRAY:
            args.append(f"tek: {arg.type.element_type.kind}")
            args.append(f"tes: {arg.type.element_type.spelling}")
        elif arg.type.kind == cix.TypeKind.CONSTANTARRAY:
            args.append(f"tek: {arg.type.element_type.kind}")
            args.append(f"tes: {arg.type.element_type.spelling}")
            args.append(f"tc: {arg.type.element_count}")
        print(" ".join(args))
    print("-" * 80)


def process_type(cursor):
    if cursor.kind == cix.CursorKind.TYPEDEF_DECL:
        underlying_type = cursor.underlying_typedef_type
        underlying_type_decl = underlying_type.get_declaration()
        underlying_type_decl_kind = underlying_type_decl.kind
        print(cursor.spelling, underlying_type.spelling, underlying_type_decl_kind)
        if underlying_type_decl_kind == cix.CursorKind.STRUCT_DECL:
            return get_struct_definition(cursor, underlying_type_decl.get_children())
        elif underlying_type_decl_kind == cix.CursorKind.ENUM_DECL:
            return get_enum_definition(cursor, underlying_type_decl.get_children())
    return None


def wrap_with_version_condition(version_condition, function):
    if version_condition is None or version_condition == "":
        return function
    return TEMPLATE_VERSION_CONDITION.substitute(
        {
            "version_condition": version_condition,
            "function": function,
        }
    )


# Define interface and implementation file paths
script_dir = os.path.dirname(os.path.abspath(__file__))
implementation_dir = os.path.join(script_dir, "../src/brahma/interface")
interface_dir = os.path.join(script_dir, "../include/brahma/interface")
test_dir = os.path.join(script_dir, "../test")

# Generate timestamp
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")


# Interface generation rules:
# brahma name
# brahma file name
# library header file name
# library header file path
# library version
# function prefix
# enable macro name
# version macro name
interfaces = []
if cli_args.hdf5_header_path and any(cli_args.hdf5_header_path):
    interfaces.append(
        (
            "hdf5",
            "hdf5",
            "hdf5.h",
            cli_args.hdf5_header_path,
            cli_args.hdf5_version,
            "H5",
            "BRAHMA_ENABLE_HDF5",
            "BRAHMA_HDF5_VERSION",
        )
    )
if cli_args.mpio_header_path:
    interfaces.append(
        (
            "mpiio",
            "mpiio",
            "mpi.h",
            [cli_args.mpio_header_path],
            [""],
            "MPI_File_",
            "BRAHMA_ENABLE_MPI",
            None,
        )
    )

index = cix.Index.create()

# Generate interfaces
for (
    brahma_name,
    brahma_file_name,
    lib_header_file_name,
    lib_header_file_paths,
    lib_versions,
    function_prefix,
    enable_macro_name,
    version_macro_name,
) in interfaces:
    print(f"[{brahma_name}] Generating interface...")

    implementation_path = f"{implementation_dir}/{brahma_file_name}.cpp"
    interface_path = f"{interface_dir}/{brahma_file_name}.h"
    test_path = f"{test_dir}/test_{brahma_file_name}.cpp"

    namespace = brahma_name.upper()

    function_arg_names = {}
    function_args = {}
    function_names = {}
    function_return_kinds = {}
    function_return_types = {}
    function_versions = {}
    macro_bindings = {}
    macro_typedefs = {}
    macro_vars = {}
    result_types = {}
    test_functions = {}
    test_function_overrides = {}
    underlying_types = {}
    virtual_functions = {}
    wrapper_functions = {}

    type_defs = {}

    for i, header_file_path in enumerate(lib_header_file_paths):
        translation_unit = index.parse(header_file_path)

        for cursor in translation_unit.cursor.get_children():
            if cursor.kind == cix.CursorKind.TYPEDEF_DECL:
                # print("-" * 80)
                # print(
                #     f"{cursor.spelling} {cursor.type.spelling} {cursor.type.get_declaration().kind}"
                # )
                # print(process_type(cursor))

                if cursor.underlying_typedef_type:
                    underlying_type = cursor.underlying_typedef_type
                    underlying_type_decl = underlying_type.get_declaration()
                    if is_basic_kind(underlying_type):
                        underlying_types[cursor.spelling] = underlying_type.spelling
                    elif underlying_type.spelling in underlying_types:
                        underlying_types[cursor.spelling] = underlying_types[
                            underlying_type.spelling
                        ]
                    elif underlying_type_decl.kind == cix.CursorKind.ENUM_DECL:
                        underlying_types[cursor.spelling] = "enum"

                #     print(underlying_type.spelling)
                #     print(underlying_type.kind)
                #     print(underlying_type.get_declaration().kind)
                #     print(underlying_type.get_declaration().get_children())
                # print("-" * 80)
                if cursor.spelling in type_defs:
                    type_defs[cursor.spelling].append(lib_versions[i])
                else:
                    type_defs[cursor.spelling] = [lib_versions[i]]

            if cursor.kind != cix.CursorKind.FUNCTION_DECL:
                continue

            if not cursor.spelling.startswith(function_prefix):
                continue

            args = []
            arg_names = []
            for arg in cursor.get_arguments():
                if arg.type.kind == cix.TypeKind.INCOMPLETEARRAY:
                    args.append(f"{arg.type.element_type.spelling} {arg.spelling}[]")
                elif arg.type.kind == cix.TypeKind.CONSTANTARRAY:
                    args.append(
                        f"{arg.type.element_type.spelling} {arg.spelling}[{arg.type.element_count}]"
                    )
                else:
                    args.append(f"{arg.type.spelling} {arg.spelling}")
                arg_names.append(arg.spelling)

            if len(args) == 0:
                args.append("void")
                arg_names.append("")

            function_signature = TEMPLATE_VIRTUAL_FUNCTION.substitute(
                {
                    "args": ", ".join(args),
                    "function_name": cursor.spelling,
                    "namespace": namespace,
                    "return_type": cursor.result_type.spelling,
                }
            )
            function_hash = hash(function_signature)

            function_arg_names[function_hash] = arg_names
            function_args[function_hash] = args
            function_names[function_hash] = cursor.spelling
            function_return_kinds[function_hash] = cursor.result_type.kind
            function_return_types[function_hash] = cursor.result_type.spelling

            print_function(cursor, function_hash)

            if function_hash in function_versions:
                function_versions[function_hash].append(lib_versions[i])
            else:
                function_versions[function_hash] = [lib_versions[i]]

    # print(function_return_kinds)
    # print(underlying_types)

    # for function_hash, return_kind in function_return_kinds.items():
    #     print(f"{function_hash}: {return_kind} {function_return_types[function_hash]}")

    # print type_def that are only found in one header version
    # for type_def, versions in type_defs.items():
    #     suffix = ""
    #     if len(versions) == 1:
    #         suffix = "<===="
    #     print(f"{type_def}: {', '.join(versions)} {suffix}")
    # exit(1)

    for function_hash, versions in function_versions.items():
        version_condition = None
        if all(versions):
            version_numbers = [version_number(version) for version in versions]
            min_version = min(version_numbers)
            max_version = max(version_numbers)
            if min_version == max_version:
                version_condition = f"{version_macro_name} >= {min_version}"
            else:
                version_condition = " && ".join(
                    [
                        f"{version_macro_name} >= {min_version}",
                        f"{version_macro_name} <= {max_version}",
                    ]
                )

        macro_bindings[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_BINDING.substitute(
                {
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                }
            ),
        )

        macro_typedefs[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_TYPEDEF.substitute(
                {
                    "arg_names": ", ".join(function_arg_names[function_hash]),
                    "args": ", ".join(function_args[function_hash]),
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                    "return_type": function_return_types[function_hash],
                }
            ),
        )

        macro_vars[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_VAR.substitute(
                {
                    "function_name": function_names[function_hash],
                }
            ),
        )

        if cli_args.with_tests:
            test_functions[function_hash] = wrap_with_version_condition(
                version_condition,
                build_test_function(
                    function_names[function_hash],
                    function_args[function_hash],
                    underlying_types,
                ),
            )

            test_function_return_kind = function_return_kinds[function_hash]
            test_function_return_type = function_return_types[function_hash]
            test_function_orig_return_type = test_function_return_type
            if test_function_return_type in underlying_types:
                test_function_return_type = underlying_types[test_function_return_type]
            test_function_return_value = ""
            if test_function_return_type == "enum":
                test_function_return_value = "return static_cast<{}>(0);".format(
                    test_function_orig_return_type
                )
            elif is_integer_type(test_function_return_type):
                test_function_return_value = "return 0;"
            elif test_function_return_kind == cix.TypeKind.VOID:
                test_function_return_value = ""
            else:
                test_function_return_value = "return NULL;"
            test_function_overrides[function_hash] = wrap_with_version_condition(
                version_condition,
                TEMPLATE_TEST_FUNCTION_OVERRIDE.substitute(
                    {
                        "args": ", ".join(function_args[function_hash]),
                        "function_name": function_names[function_hash],
                        "return_type": function_return_types[function_hash],
                        "return_value": test_function_return_value,
                    }
                ),
            )

        virtual_functions[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_VIRTUAL_FUNCTION.substitute(
                {
                    "args": ", ".join(function_args[function_hash]),
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                    "return_type": function_return_types[function_hash],
                }
            ),
        )

        if function_return_kinds[function_hash] == cix.TypeKind.VOID:
            wrapper_functions[function_hash] = wrap_with_version_condition(
                version_condition,
                TEMPLATE_WRAPPER_FUNCTION_VOID.substitute(
                    {
                        "arg_names": ", ".join(function_arg_names[function_hash]),
                        "args": ", ".join(function_args[function_hash]),
                        "function_name": function_names[function_hash],
                        "namespace": namespace,
                    }
                ),
            )
        else:
            wrapper_functions[function_hash] = wrap_with_version_condition(
                version_condition,
                TEMPLATE_WRAPPER_FUNCTION.substitute(
                    {
                        "arg_names": ", ".join(function_arg_names[function_hash]),
                        "args": ", ".join(function_args[function_hash]),
                        "function_name": function_names[function_hash],
                        "namespace": namespace,
                        "return_type": function_return_types[function_hash],
                    }
                ),
            )

    with open(interface_path, "w+") as interface_file:
        interface_file.write(
            TEMPLATE_INTERFACE.substitute(
                {
                    "enable_macro_name": enable_macro_name,
                    "file_name": brahma_file_name,
                    "lib_header_file_name": lib_header_file_name,
                    "macro_bindings": "".join(macro_bindings.values()),
                    "macro_typedefs": "".join(macro_typedefs.values()),
                    "macro_vars": "".join(macro_vars.values()),
                    "namespace": namespace,
                    "timestamp": timestamp,
                    "virtual_functions": "".join(virtual_functions.values()),
                }
            )
        )

    with open(implementation_path, "w+") as implementation_file:
        implementation_file.write(
            TEMPLATE_IMPLEMENTATION.substitute(
                {
                    "enable_macro_name": enable_macro_name,
                    "file_name": brahma_file_name,
                    "namespace": namespace,
                    "timestamp": timestamp,
                    "wrapper_functions": "".join(wrapper_functions.values()),
                }
            )
        )

    if cli_args.with_tests:
        with open(test_path, "w+") as test_file:
            test_file.write(
                TEMPLATE_TEST.substitute(
                    {
                        "enable_macro_name": enable_macro_name,
                        "file_name": brahma_file_name,
                        "function_overrides": "".join(test_function_overrides.values()),
                        "lib_header_file_name": lib_header_file_name,
                        "namespace": namespace,
                        "test_functions": "".join(test_functions.values()),
                        "timestamp": timestamp,
                    }
                )
            )

    print(f"[{brahma_name}] Generated {len(macro_vars)} functions")

    if shutil.which("clang-format") is None:
        print(f"[{brahma_name}] clang-format not found, skipping formatting")
    else:
        print(f"[{brahma_name}] Formatting files using clang-format...")
        os.system(f"clang-format -i {interface_path}")
        os.system(f"clang-format -i {implementation_path}")
        if cli_args.with_tests:
            os.system(f"clang-format -i {test_path}")

    print(f"[{brahma_name}] Done!")
