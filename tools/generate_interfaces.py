import argparse
import clang.cindex as cix
import os
import shutil
from datetime import datetime
from string import Template

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Generate interfaces script")
parser.add_argument("--libclang-path", type=str, help="Path to libclang", required=True)
parser.add_argument(
    "--hdf5-header-path",
    action="extend",
    nargs="+",
    type=str,
    help="Path to HDF5 library header file",
)
parser.add_argument(
    "--hdf5-version",
    action="extend",
    nargs="+",
    type=str,
    help="Version of HDF5 related to header file",
)
parser.add_argument(
    "--mpio-header-path",
    type=str,
    help="Path to MPIO library header file",
)
parser.add_argument(
    "--verbose", action="store_true", help="Print verbose output", default=False
)
cli_args = parser.parse_args()

cix.Config.set_library_file(cli_args.libclang_path)


TEMPLATE_IMPLEMENTATION = Template("""
///
/// This file is generated by tools/generate_interfaces.py
/// Generated on: ${timestamp}
///

#include <brahma/interface/${file_name}.h>
#include <stdexcept>
#ifdef ${enable_macro_name}
                                   
namespace brahma {
    std::shared_ptr<${namespace}> ${namespace}::my_instance = nullptr;
                                   
    std::shared_ptr<${namespace}> ${namespace}::get_instance() {
        if (my_instance == nullptr) {
            BRAHMA_LOG_INFO("${namespace} class not intercepted but used", "");
            my_instance = std::make_shared<${namespace}>();
        }
        return my_instance;
    }
                                   
    int ${namespace}::set_instance(std::shared_ptr<${namespace}> instance_i) {
        if (instance_i != nullptr) {
            my_instance = instance_i;
            return 0;
        } else {
            BRAHMA_LOG_ERROR("%s instance_i is not set", "${namespace}");
            throw std::runtime_error("instance_i is not set");
        }
    }
 
    ${wrapper_functions}
} // namespace brahma

#endif // ${enable_macro_name}
""")

TEMPLATE_INTERFACE = Template("""
///
/// This file is generated by tools/generate_interfaces.py
/// Generated on: ${timestamp}
///

#ifndef BRAHMA_${namespace}_H
#define BRAHMA_${namespace}_H
#include <brahma/brahma_config.hpp>
#ifdef ${enable_macro_name}
#include <brahma/interceptor.h>
#include <brahma/interface/interface.h>
#include <${lib_header_file_name}>

namespace brahma {
    class ${namespace} : public Interface {
        private:
            static std::shared_ptr<${namespace}> my_instance;
                             
        public:
            ${namespace}() : Interface() {};
            
            virtual ~${namespace}() {};

            static std::shared_ptr<${namespace}> get_instance();
                             
            static int set_instance(std::shared_ptr<${namespace}> instance_i);
                              
            template <typename C>
            size_t bind(const char *name, uint16_t priority);
                              
            ${virtual_functions}

            ${macro_vars}
    };
} // namespace brahma

${macro_typedefs}

template <typename C>
size_t brahma::${namespace}::bind(const char *name, uint16_t priority) {
    ${macro_bindings}
                              
    num_bindings = bindings.size();
    if (num_bindings > 0) {
        char tool_name[64];
        sprintf(tool_name, "%s_${file_name}", name);
        gotcha_binding_t *raw_bindings = bindings.data();
        gotcha_wrap(raw_bindings, num_bindings, tool_name);
        gotcha_set_priority(tool_name, priority);
    }
    return num_bindings;  
}

#endif // ${enable_macro_name}
#endif // BRAHMA_${namespace}_H
""")

TEMPLATE_MACRO_BINDING = Template("""
GOTCHA_BINDING_MACRO(${function_name}, brahma::${namespace});
""")

TEMPLATE_MACRO_TYPEDEF = Template("""
GOTCHA_MACRO_TYPEDEF(${function_name}, ${return_type}, (${args}), (${arg_names}), brahma::${namespace});
""")

TEMPLATE_MACRO_VAR = Template("""
GOTCHA_MACRO_VAR(${function_name})
""")

TEMPLATE_VERSION_CONDITION = Template("""
#if ${version_condition} ${function} #endif
""")

TEMPLATE_VIRTUAL_FUNCTION = Template("""
virtual ${return_type} ${function_name}(${args});
""")

TEMPLATE_WRAPPER_FUNCTION = Template("""
${return_type} ${namespace}::${function_name}(${args}) {
    BRAHMA_UNWRAPPED_FUNC(${function_name}, ${return_type}, (${arg_names}));
    return result;
}
""")

TEMPLATE_WRAPPER_FUNCTION_VOID = Template("""
void ${namespace}::${function_name}(${args}) {
    BRAHMA_UNWRAPPED_FUNC_VOID(${function_name}, (${arg_names}));
}
""")


def version_number(version_string: str):
    version_parts = version_string.split(".")
    while len(version_parts) < 3:
        version_parts.append("0")
    return (
        int(version_parts[0]) * 100000
        + int(version_parts[1]) * 100
        + int(version_parts[2])
    )


def get_struct_definition(cursor, struct_children):
    struct_def = f"typedef struct {cursor.spelling} {{\n"
    for field in struct_children:
        struct_def += f"    {field.type.spelling} {field.spelling};\n"
    struct_def += f"}} {cursor.spelling};\n"
    return struct_def


def get_enum_definition(cursor, enum_children):
    enum_def = f"typedef enum {cursor.spelling} {{\n"
    for enum_const in enum_children:
        if enum_const.kind == cix.CursorKind.ENUM_CONSTANT_DECL:
            enum_def += f"    {enum_const.spelling} = {enum_const.enum_value},\n"
    enum_def += f"}} {cursor.spelling};\n"
    return enum_def


def print_function(cursor, function_hash=""):
    if not cli_args.verbose:
        return
    print("-" * 80)
    print(f"[func] {cursor.spelling} ({function_hash})")
    for i, arg in enumerate(cursor.get_arguments()):
        args = []
        args.append(f"[arg{i}]")
        args.append(f"s: {arg.spelling}")
        args.append(f"tk: {arg.type.kind}")
        args.append(f"ts: {arg.type.spelling}")
        if arg.type.kind == cix.TypeKind.INCOMPLETEARRAY:
            args.append(f"tek: {arg.type.element_type.kind}")
            args.append(f"tes: {arg.type.element_type.spelling}")
        elif arg.type.kind == cix.TypeKind.CONSTANTARRAY:
            args.append(f"tek: {arg.type.element_type.kind}")
            args.append(f"tes: {arg.type.element_type.spelling}")
            args.append(f"tc: {arg.type.element_count}")
        print(" ".join(args))
    print("-" * 80)


def process_type(cursor):
    if cursor.kind == cix.CursorKind.TYPEDEF_DECL:
        underlying_type = cursor.underlying_typedef_type
        underlying_type_decl = underlying_type.get_declaration()
        underlying_type_decl_kind = underlying_type_decl.kind
        print(cursor.spelling, underlying_type.spelling, underlying_type_decl_kind)
        if underlying_type_decl_kind == cix.CursorKind.STRUCT_DECL:
            return get_struct_definition(cursor, underlying_type_decl.get_children())
        elif underlying_type_decl_kind == cix.CursorKind.ENUM_DECL:
            return get_enum_definition(cursor, underlying_type_decl.get_children())
    return None


def wrap_with_version_condition(version_condition, function):
    if version_condition is None or version_condition == "":
        return function
    return TEMPLATE_VERSION_CONDITION.substitute(
        {
            "version_condition": version_condition,
            "function": function,
        }
    )


# Define interface and implementation file paths
script_dir = os.path.dirname(os.path.abspath(__file__))
implementation_dir = os.path.join(script_dir, "../src/brahma/interface")
interface_dir = os.path.join(script_dir, "../include/brahma/interface")

# Generate timestamp
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")


# Interface generation rules:
# brahma name
# brahma file name
# library header file name
# library header file path
# library version
# function prefix
# enable macro name
# version macro name
interfaces = []
if any(cli_args.hdf5_header_path):
    interfaces.append(
        (
            "hdf5",
            "hdf5",
            "hdf5.h",
            cli_args.hdf5_header_path,
            cli_args.hdf5_version,
            "H5",
            "BRAHMA_ENABLE_HDF5",
            "BRAHMA_HDF5_VERSION",
        )
    )
if cli_args.mpio_header_path:
    interfaces.append(
        (
            "mpiio",
            "mpiio",
            "mpi.h",
            [cli_args.mpio_header_path],
            [""],
            "MPI_File_",
            "BRAHMA_ENABLE_MPI",
            None,
        )
    )

index = cix.Index.create()

# Generate interfaces
for (
    brahma_name,
    brahma_file_name,
    lib_header_file_name,
    lib_header_file_paths,
    lib_versions,
    function_prefix,
    enable_macro_name,
    version_macro_name,
) in interfaces:
    print(f"[{brahma_name}] Generating interface...")

    implementation_path = f"{implementation_dir}/{brahma_file_name}.cpp"
    interface_path = f"{interface_dir}/{brahma_file_name}.h"

    namespace = brahma_name.upper()

    function_arg_names = {}
    function_args = {}
    function_names = {}
    function_return_kinds = {}
    function_return_types = {}
    function_versions = {}
    macro_bindings = {}
    macro_typedefs = {}
    macro_vars = {}
    result_types = {}
    virtual_functions = {}
    wrapper_functions = {}

    type_defs = {}

    for i, header_file_path in enumerate(lib_header_file_paths):
        translation_unit = index.parse(header_file_path)

        for cursor in translation_unit.cursor.get_children():
            if cursor.kind == cix.CursorKind.TYPEDEF_DECL:
                # print("-" * 80)
                # print(f"{cursor.spelling} {cursor.type.get_declaration().kind}")
                # print(process_type(cursor))
                # print("-" * 80)

                if cursor.spelling in type_defs:
                    type_defs[cursor.spelling].append(lib_versions[i])
                else:
                    type_defs[cursor.spelling] = [lib_versions[i]]

            if cursor.kind != cix.CursorKind.FUNCTION_DECL:
                continue

            if not cursor.spelling.startswith(function_prefix):
                continue

            args = []
            arg_names = []
            for arg in cursor.get_arguments():
                if arg.type.kind == cix.TypeKind.INCOMPLETEARRAY:
                    args.append(f"{arg.type.element_type.spelling} {arg.spelling}[]")
                elif arg.type.kind == cix.TypeKind.CONSTANTARRAY:
                    args.append(
                        f"{arg.type.element_type.spelling} {arg.spelling}[{arg.type.element_count}]"
                    )
                else:
                    args.append(f"{arg.type.spelling} {arg.spelling}")
                arg_names.append(arg.spelling)

                # I:
                # hash arguments and return types
                # check hash for each header version
                # create a set of functions > resolve hashes have an overlap or not

                # II:
                # for every hash functions, how many versions match
                # if no match, add to the set
                # if match, keep the versions per those hash functions

            if len(args) == 0:
                args.append("void")
                arg_names.append("")

            function_signature = TEMPLATE_VIRTUAL_FUNCTION.substitute(
                {
                    "args": ", ".join(args),
                    "function_name": cursor.spelling,
                    "namespace": namespace,
                    "return_type": cursor.result_type.spelling,
                }
            )
            function_hash = hash(function_signature)

            function_arg_names[function_hash] = arg_names
            function_args[function_hash] = args
            function_names[function_hash] = cursor.spelling
            function_return_kinds[function_hash] = cursor.result_type.kind
            function_return_types[function_hash] = cursor.result_type.spelling

            print_function(cursor, function_hash)

            if function_hash in function_versions:
                function_versions[function_hash].append(lib_versions[i])
            else:
                function_versions[function_hash] = [lib_versions[i]]

    # print(function_return_kinds)

    # for function_hash, return_kind in function_return_kinds.items():
    #     print(f"{function_hash}: {return_kind} {function_return_types[function_hash]}")

    # print type_def that are only found in one header version
    # for type_def, versions in type_defs.items():
    #     suffix = ""
    #     if len(versions) == 1:
    #         suffix = "<===="
    #     print(f"{type_def}: {', '.join(versions)} {suffix}")
    # exit(1)

    for function_hash, versions in function_versions.items():
        version_condition = None
        if all(versions):
            version_numbers = [version_number(version) for version in versions]
            min_version = min(version_numbers)
            max_version = max(version_numbers)
            if min_version == max_version:
                version_condition = f"{version_macro_name} >= {min_version}"
            else:
                version_condition = " && ".join(
                    [
                        f"{version_macro_name} >= {min_version}",
                        f"{version_macro_name} <= {max_version}",
                    ]
                )

        macro_bindings[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_BINDING.substitute(
                {
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                }
            ),
        )

        macro_typedefs[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_TYPEDEF.substitute(
                {
                    "arg_names": ", ".join(function_arg_names[function_hash]),
                    "args": ", ".join(function_args[function_hash]),
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                    "return_type": function_return_types[function_hash],
                }
            ),
        )

        macro_vars[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_MACRO_VAR.substitute(
                {
                    "function_name": function_names[function_hash],
                }
            ),
        )

        virtual_functions[function_hash] = wrap_with_version_condition(
            version_condition,
            TEMPLATE_VIRTUAL_FUNCTION.substitute(
                {
                    "args": ", ".join(function_args[function_hash]),
                    "function_name": function_names[function_hash],
                    "namespace": namespace,
                    "return_type": function_return_types[function_hash],
                }
            ),
        )

        if function_return_kinds[function_hash] == cix.TypeKind.VOID:
            wrapper_functions[function_hash] = wrap_with_version_condition(
                version_condition,
                TEMPLATE_WRAPPER_FUNCTION_VOID.substitute(
                    {
                        "arg_names": ", ".join(function_arg_names[function_hash]),
                        "args": ", ".join(function_args[function_hash]),
                        "function_name": function_names[function_hash],
                        "namespace": namespace,
                    }
                ),
            )
        else:
            wrapper_functions[function_hash] = wrap_with_version_condition(
                version_condition,
                TEMPLATE_WRAPPER_FUNCTION.substitute(
                    {
                        "arg_names": ", ".join(function_arg_names[function_hash]),
                        "args": ", ".join(function_args[function_hash]),
                        "function_name": function_names[function_hash],
                        "namespace": namespace,
                        "return_type": function_return_types[function_hash],
                    }
                ),
            )

    with open(interface_path, "w+") as interface_file:
        interface_file.write(
            TEMPLATE_INTERFACE.substitute(
                {
                    "enable_macro_name": enable_macro_name,
                    "file_name": brahma_file_name,
                    "lib_header_file_name": lib_header_file_name,
                    "macro_bindings": "".join(macro_bindings.values()),
                    "macro_typedefs": "".join(macro_typedefs.values()),
                    "macro_vars": "".join(macro_vars.values()),
                    "namespace": namespace,
                    "timestamp": timestamp,
                    "virtual_functions": "".join(virtual_functions.values()),
                }
            )
        )

    with open(implementation_path, "w+") as implementation_file:
        implementation_file.write(
            TEMPLATE_IMPLEMENTATION.substitute(
                {
                    "enable_macro_name": enable_macro_name,
                    "file_name": brahma_file_name,
                    "namespace": namespace,
                    "timestamp": timestamp,
                    "wrapper_functions": "".join(wrapper_functions.values()),
                }
            )
        )

    print(f"[{brahma_name}] Generated {len(macro_vars)} functions")

    if shutil.which("clang-format") is None:
        print(f"[{brahma_name}] clang-format not found, skipping formatting")
    else:
        print(f"[{brahma_name}] Formatting files using clang-format...")
        os.system(f"clang-format -i {interface_path}")
        os.system(f"clang-format -i {implementation_path}")

    print(f"[{brahma_name}] Done!")
